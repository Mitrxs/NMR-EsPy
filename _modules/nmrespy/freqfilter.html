
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nmrespy.freqfilter &#8212; NMR-EsPy  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/nameko.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Lora:400' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  </head><body>
  
  

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">NMR-EsPy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">nmrespy.freqfilter</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for nmrespy.freqfilter</h1><div class="highlight"><pre>
<span></span><span class="c1"># freqfilter.py</span>
<span class="c1"># Simon Hulse</span>
<span class="c1"># simon.hulse@chem.ox.ac.uk</span>
<span class="c1"># Last Edited: Wed 06 Jul 2022 15:55:10 BST</span>

<span class="sd">&quot;&quot;&quot;Frequecy filtration of NMR data using super-Gaussian band-pass filters.</span>

<span class="sd">MWE</span>
<span class="sd">---</span>

<span class="sd">.. literalinclude:: examples/filter_example.py</span>

<span class="sd">.. image:: media/filter_example.png</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># TODO: I have commeneted out all code relating to baseline fixing.</span>
<span class="c1"># I may look into this in the future to see if I can achieve improvements</span>
<span class="c1"># in filtering performance.</span>
<span class="c1"># SH, 16-3-22</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">nlinalg</span>
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="k">as</span> <span class="nn">nrandom</span>
<span class="c1"># from scipy.optimize import minimize</span>

<span class="kn">from</span> <span class="nn">nmrespy</span> <span class="kn">import</span> <span class="n">ExpInfo</span>
<span class="kn">from</span> <span class="nn">nmrespy._sanity</span> <span class="kn">import</span> <span class="n">sanity_check</span><span class="p">,</span> <span class="n">funcs</span> <span class="k">as</span> <span class="n">sfuncs</span>
<span class="kn">from</span> <span class="nn">nmrespy</span> <span class="kn">import</span> <span class="n">sig</span>


<span class="c1"># Long-winded region types</span>
<span class="n">RegionFloat</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
<span class="n">RegionInt</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
<span class="n">Region</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">RegionInt</span><span class="p">,</span> <span class="n">RegionFloat</span><span class="p">]</span>


<div class="viewcode-block" id="Filter"><a class="viewcode-back" href="../../content/references/freqfilter.html#nmrespy.freqfilter.Filter">[docs]</a><span class="k">class</span> <span class="nc">Filter</span><span class="p">(</span><span class="n">ExpInfo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object with tools to generate frequency-filtered NMR data.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">expinfo</span><span class="p">:</span> <span class="n">ExpInfo</span><span class="p">,</span>
        <span class="n">region</span><span class="p">:</span> <span class="n">Region</span><span class="p">,</span>
        <span class="n">noise_region</span><span class="p">:</span> <span class="n">Region</span><span class="p">,</span>
        <span class="n">strict_region_order</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">region_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hz&quot;</span><span class="p">,</span>
        <span class="n">sg_power</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">40.0</span><span class="p">,</span>
        <span class="n">twodim_dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialise an instance of the class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fid</span>
<span class="sd">            Time-domain data to derive frequency-filtered data from.</span>

<span class="sd">        expinfo</span>
<span class="sd">            Experiment Information.</span>

<span class="sd">        region</span>
<span class="sd">            Region (in array indices) of the spectrum selected for filtration.</span>

<span class="sd">        noise_region</span>
<span class="sd">            Region (in array indices) of the spectrum selected for determining</span>
<span class="sd">            the noise variance.</span>

<span class="sd">        region_unit</span>
<span class="sd">            The units which the boundaries in `region` and `noise_region` are</span>
<span class="sd">            given in. Should be one of ``&quot;hz&quot;`` or ``&quot;ppm&quot;``.</span>

<span class="sd">        sg_power</span>
<span class="sd">            Power of the super-Gaussian. The greater the value, the more box-like</span>
<span class="sd">            the filter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Region specification**</span>

<span class="sd">        For a :math:`d`-dimensional experiment, the ``region`` and</span>
<span class="sd">        ``noise_region`` arguments should be array-like objects (``list``,</span>
<span class="sd">        ``tuple``, etc.) containing :math:`d` length-2 array-like objects. Each</span>
<span class="sd">        of these specifies the boundaries of the region of interest in each</span>
<span class="sd">        dimension. If no filtering is to be applied to a particular dimension</span>
<span class="sd">        (i.e. the F1 dimension of a pseudo-2D dataset), set the element for</span>
<span class="sd">        this dimension to ``None``.</span>

<span class="sd">        As an example, for a 2-dimensional dataset, where the desired region is</span>
<span class="sd">        from 4 - 4.5ppm in dimension 1 and 1.2 - 1.6ppm in dimension 2,</span>
<span class="sd">        ``region`` would be specified as: ``((4., 4.5), (1.2, 1.6))``. Note</span>
<span class="sd">        that the order of values in each dimension is not important. Also,</span>
<span class="sd">        ``region_unit`` would have to be manually set as ``&#39;ppm&#39;`` in this</span>
<span class="sd">        example, as regions are expected in Hz by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sanity_check</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;expinfo&quot;</span><span class="p">,</span> <span class="n">expinfo</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_expinfo</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;sg_power&quot;</span><span class="p">,</span> <span class="n">sg_power</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_float</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="s2">&quot;greater_than_one&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
            <span class="p">(</span><span class="s2">&quot;fid&quot;</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_ndarray</span><span class="p">,</span> <span class="p">(</span><span class="n">expinfo</span><span class="o">.</span><span class="n">dim</span><span class="p">,)),</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fid</span> <span class="o">=</span> <span class="n">fid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sg_power</span> <span class="o">=</span> <span class="n">sg_power</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">dim</span><span class="o">=</span><span class="n">expinfo</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
            <span class="n">sw</span><span class="o">=</span><span class="n">expinfo</span><span class="o">.</span><span class="n">sw</span><span class="p">(</span><span class="s2">&quot;hz&quot;</span><span class="p">),</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">expinfo</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="s2">&quot;hz&quot;</span><span class="p">),</span>
            <span class="n">sfo</span><span class="o">=</span><span class="n">expinfo</span><span class="o">.</span><span class="n">sfo</span><span class="p">,</span>
            <span class="n">nuclei</span><span class="o">=</span><span class="n">expinfo</span><span class="o">.</span><span class="n">nuclei</span><span class="p">,</span>
            <span class="n">default_pts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">fn_mode</span><span class="o">=</span><span class="n">expinfo</span><span class="o">.</span><span class="n">fn_mode</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sanity_check</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;twodim_dtype&quot;</span><span class="p">,</span> <span class="n">twodim_dtype</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_one_of</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;jres&quot;</span><span class="p">,)),</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">sanity_check</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;twodim_dtype&quot;</span><span class="p">,</span> <span class="n">twodim_dtype</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_one_of</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;amp&quot;</span><span class="p">,</span> <span class="s2">&quot;phase&quot;</span><span class="p">)),</span>
            <span class="p">)</span>

        <span class="n">sanity_check</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;region_unit&quot;</span><span class="p">,</span> <span class="n">region_unit</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_frequency_unit</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hz_ppm_valid</span><span class="p">,),</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="n">region_check_args</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sw</span><span class="p">(</span><span class="n">region_unit</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">region_unit</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">sanity_check</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;region&quot;</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_region</span><span class="p">,</span> <span class="n">region_check_args</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;noise_region&quot;</span><span class="p">,</span> <span class="n">noise_region</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_region</span><span class="p">,</span> <span class="n">region_check_args</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">ve</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">make_virtual_echo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fid</span><span class="p">,</span> <span class="n">twodim_dtype</span><span class="p">)</span>
        <span class="c1"># Need to set default points before using the frequency converter</span>
        <span class="c1"># to convert to array indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_pts</span> <span class="o">=</span> <span class="n">ve</span><span class="o">.</span><span class="n">shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_region</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">region_unit</span><span class="p">,</span> <span class="n">strict_region_order</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_region</span><span class="p">(</span><span class="n">noise_region</span><span class="p">,</span> <span class="n">region_unit</span><span class="p">,</span> <span class="n">strict_region_order</span><span class="p">)</span>  <span class="c1"># noqa: E501</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spectrum</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">ft</span><span class="p">(</span><span class="n">ve</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                <span class="p">[</span><span class="n">i</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_region</span><span class="p">)],</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_region</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">region</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">region_unit</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">strict_region_order</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">region</span> <span class="o">=</span> <span class="p">[</span><span class="n">region</span><span class="p">]</span>

        <span class="n">sort_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span> <span class="k">if</span> <span class="n">strict_region_order</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">sort_func</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">region_unit</span><span class="si">}</span><span class="s2">-&gt;idx&quot;</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get unfiltered spectrum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spectrum</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get super-Gaussian filter.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_sg&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_superg</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sg</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sg_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get additive noise vector.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_sg_noise&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sg_noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_superg_noise</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sg_noise</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get shape of the spectrum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sg_power</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the power of the Super-Gaussian.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sg_power</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_filtered_unfixed_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filtered spectrum without any baseline fix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg_noise</span>

<div class="viewcode-block" id="Filter.get_filtered_spectrum"><a class="viewcode-back" href="../../content/references/freqfilter.html#nmrespy.freqfilter.Filter.get_filtered_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">get_filtered_spectrum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">cut_ratio</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">,</span>
        <span class="c1"># fix_baseline: bool = False,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ExpInfo</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get filtered spectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cut_ratio</span>
<span class="sd">            If a float, the filtered frequency-domain data will be trancated</span>
<span class="sd">            reducing the number of signal points. ``cut_ratio`` gives the ratio of</span>
<span class="sd">            the cut spectrum&#39;s bandwidth and the filter bandwidth. This should be</span>
<span class="sd">            greater than ``1.0``. If ``None``, no spectrum truncation will be carried</span>
<span class="sd">            out.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filtered_spectrum</span>
<span class="sd">            Filtered spectrum.</span>

<span class="sd">        expinfo</span>
<span class="sd">            Experiment information corresponding to the filtered signal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sanity_check</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;cut_ratio&quot;</span><span class="p">,</span> <span class="n">cut_ratio</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_float</span><span class="p">,</span> <span class="p">(),</span>
                <span class="p">{</span><span class="s2">&quot;greater_than_one&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># (&quot;fix_baseline&quot;, fix_baseline, sfuncs.check_bool),</span>
        <span class="p">)</span>

        <span class="n">filtered_spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_unfixed_spectrum</span>
        <span class="c1"># if fix_baseline:</span>
        <span class="c1">#     filtered_spectrum += self._baseline_fix(filtered_spectrum)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cut_ratio</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">filtered_spectrum</span> <span class="o">=</span> <span class="n">filtered_spectrum</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cut_slice</span><span class="p">(</span><span class="n">cut_ratio</span><span class="p">)]</span>
            <span class="n">scaling_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cut_scaling_factor</span><span class="p">(</span><span class="n">cut_ratio</span><span class="p">)</span>
            <span class="n">filtered_spectrum</span> <span class="o">*=</span> <span class="n">scaling_factor</span>

            <span class="n">cut_hz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cut_indices</span><span class="p">(</span><span class="n">cut_ratio</span><span class="p">),</span> <span class="s2">&quot;idx-&gt;hz&quot;</span>
            <span class="p">)</span>
            <span class="n">sw</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">lft</span> <span class="o">-</span> <span class="n">rgt</span><span class="p">)</span> <span class="k">for</span> <span class="n">lft</span><span class="p">,</span> <span class="n">rgt</span> <span class="ow">in</span> <span class="n">cut_hz</span><span class="p">])</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([(</span><span class="n">lft</span> <span class="o">+</span> <span class="n">rgt</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">lft</span><span class="p">,</span> <span class="n">rgt</span> <span class="ow">in</span> <span class="n">cut_hz</span><span class="p">])</span>
            <span class="n">sfo</span><span class="p">,</span> <span class="n">nuclei</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span>

            <span class="n">expinfo</span> <span class="o">=</span> <span class="n">ExpInfo</span><span class="p">(</span>
                <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
                <span class="n">sw</span><span class="o">=</span><span class="n">sw</span><span class="p">,</span>
                <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                <span class="n">sfo</span><span class="o">=</span><span class="n">sfo</span><span class="p">,</span>
                <span class="n">nuceli</span><span class="o">=</span><span class="n">nuclei</span><span class="p">,</span>
                <span class="n">default_pts</span><span class="o">=</span><span class="n">filtered_spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">expinfo</span> <span class="o">=</span> <span class="n">ExpInfo</span><span class="p">(</span>
                <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
                <span class="n">sw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sw</span><span class="p">(</span><span class="s2">&quot;hz&quot;</span><span class="p">),</span>
                <span class="n">offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="s2">&quot;hz&quot;</span><span class="p">),</span>
                <span class="n">sfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sfo</span><span class="p">,</span>
                <span class="n">nuceli</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">,</span>
                <span class="n">default_pts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_pts</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">filtered_spectrum</span><span class="p">,</span> <span class="n">expinfo</span></div>

<div class="viewcode-block" id="Filter.get_filtered_fid"><a class="viewcode-back" href="../../content/references/freqfilter.html#nmrespy.freqfilter.Filter.get_filtered_fid">[docs]</a>    <span class="k">def</span> <span class="nf">get_filtered_fid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cut_ratio</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">,</span>
        <span class="c1"># fix_baseline: bool = False,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ExpInfo</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get filtered FID.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cut_ratio</span>
<span class="sd">            If a float, the filtered frequency-domain data will be trancated prior</span>
<span class="sd">            to IFT, reducing the number of signal points. ``cut_ratio`` gives the</span>
<span class="sd">            ratio of the cut spectrum&#39;s bandwidth and the filter bandwidth. This</span>
<span class="sd">            must be greater than ``1.0``. If ``None``, no spectrum truncation will</span>
<span class="sd">            be carried out before IFT.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered_spectrum</span><span class="p">,</span> <span class="n">expinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filtered_spectrum</span><span class="p">(</span>
            <span class="n">cut_ratio</span><span class="o">=</span><span class="n">cut_ratio</span><span class="p">,</span>  <span class="c1"># fix_baseline=fix_baseline</span>
        <span class="p">)</span>
        <span class="n">filtered_fid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ift_and_slice</span><span class="p">(</span><span class="n">filtered_spectrum</span><span class="p">)</span>
        <span class="n">expinfo</span><span class="o">.</span><span class="n">_default_pts</span> <span class="o">=</span> <span class="n">filtered_fid</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">filtered_fid</span><span class="p">,</span> <span class="n">expinfo</span></div>

    <span class="k">def</span> <span class="nf">_superg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Super-Gaussian for filtration of frequency-domian data.</span>

<span class="sd">        The super-Gaussian is described by the following expression:</span>

<span class="sd">        .. math::</span>

<span class="sd">          g\left[n_1, \cdots, n_D\right] =</span>
<span class="sd">          \exp \left[ \sum\limits_{d=1}^D -2^{p+1}</span>
<span class="sd">          \left(\frac{n_d - c_d}{b_d}\right)^p\right]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s2">&quot;idx&quot;</span><span class="p">)</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bw</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s2">&quot;idx&quot;</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg_power</span>

        <span class="c1"># Construct super gaussian</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">bw</span><span class="p">)):</span>
            <span class="c1"># 1D array of super-Gaussian for particular dimension</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="o">**</span> <span class="n">p</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sg</span> <span class="o">=</span> <span class="n">s</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sg</span> <span class="o">=</span> <span class="n">sg</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span>

        <span class="k">return</span> <span class="n">sg</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_superg_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Construct a synthetic noise sequence to add to the filtered spectrum.&quot;&quot;&quot;</span>
        <span class="n">noise_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">slice</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_noise_region</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s2">&quot;idx&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spectrum</span><span class="p">)[</span><span class="n">noise_slice</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="c1"># Remove linear term from noise. Goal is to remove non-flat baseline shape</span>
        <span class="c1"># from contributing to the noise variance determination.</span>
        <span class="n">noise</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear_correction</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>

        <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
        <span class="n">sg_noise</span> <span class="o">=</span> <span class="n">nrandom</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Scale noise elements according to corresponding value of the</span>
        <span class="c1"># super-Gaussian filter</span>
        <span class="n">sg_noise</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sg</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sg_noise</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_linear_correction</span><span class="p">(</span><span class="n">noise</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Determine linear component in noise array.</span>

<span class="sd">        Utilised as a means to improve the noise variance computation (see</span>
<span class="sd">        :py:meth:`_superg_noise`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        noise</span>
<span class="sd">            Noise array to correct.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        correction</span>
<span class="sd">            Linear term to remove from the noise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">noise</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">noise</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">noise</span><span class="o">.</span><span class="n">size</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">X</span> <span class="o">@</span> <span class="p">(</span><span class="n">nlinalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">X</span><span class="p">)</span> <span class="o">@</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cut_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;L and R bounds of cut spectrum in relation to the full spectrum.&quot;&quot;&quot;</span>
        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s2">&quot;idx&quot;</span><span class="p">)</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bw</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s2">&quot;idx&quot;</span><span class="p">)</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">cut_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">bw</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mn</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mn</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cut_ratio</span><span class="p">)))</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cut_ratio</span><span class="p">)))</span>
                <span class="c1"># ensure the cut region remains within the valid span of</span>
                <span class="c1"># values (0 -&gt; n-1)</span>
                <span class="k">if</span> <span class="n">mn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mn</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">mx</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
                    <span class="n">mx</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">cut_idx</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mn</span><span class="p">,</span> <span class="n">mx</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cut_idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cut_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">slice</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Slice to extract cut spectrum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">lft</span><span class="p">,</span> <span class="n">rgt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">lft</span><span class="p">,</span> <span class="n">rgt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cut_indices</span><span class="p">(</span><span class="n">cut_ratio</span><span class="p">)]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cut_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Shape of a cut spectrum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">rgt</span> <span class="o">-</span> <span class="n">lft</span> <span class="k">for</span> <span class="n">lft</span><span class="p">,</span> <span class="n">rgt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cut_indices</span><span class="p">(</span><span class="n">cut_ratio</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_cut_scaling_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Ratio of size of cut spectrum and full spectrum in each dimension.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
            <span class="p">[</span><span class="n">cut</span> <span class="o">/</span> <span class="n">uncut</span> <span class="k">for</span> <span class="n">cut</span><span class="p">,</span> <span class="n">uncut</span> <span class="ow">in</span>
             <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cut_shape</span><span class="p">(</span><span class="n">cut_ratio</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)],</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Filter.get_center"><a class="viewcode-back" href="../../content/references/freqfilter.html#nmrespy.freqfilter.Filter.get_center">[docs]</a>    <span class="k">def</span> <span class="nf">get_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hz&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Get the center of the super-Gaussian filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit</span>
<span class="sd">            Unit specifier. Should be one of ``&#39;idx&#39;``, ``&#39;hz&#39;``, ``&#39;ppm&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sanity_check</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_one_of</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;idx&quot;</span><span class="p">,</span> <span class="s2">&quot;hz&quot;</span><span class="p">,</span> <span class="s2">&quot;ppm&quot;</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="n">region_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_region</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s2">&quot;idx&quot;</span><span class="p">)</span>
        <span class="n">center_idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
             <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">region_idx</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">center_idx</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;idx-&gt;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Filter.get_bw"><a class="viewcode-back" href="../../content/references/freqfilter.html#nmrespy.freqfilter.Filter.get_bw">[docs]</a>    <span class="k">def</span> <span class="nf">get_bw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hz&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Get the bandwidth of the super-Gaussian filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit</span>
<span class="sd">            Unit specifier. Should be one of ``&#39;idx&#39;``, ``&#39;hz&#39;``, ``&#39;ppm&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sanity_check</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_one_of</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;idx&quot;</span><span class="p">,</span> <span class="s2">&quot;hz&quot;</span><span class="p">,</span> <span class="s2">&quot;ppm&quot;</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_region</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">region</span><span class="p">])</span></div>

<div class="viewcode-block" id="Filter.get_region"><a class="viewcode-back" href="../../content/references/freqfilter.html#nmrespy.freqfilter.Filter.get_region">[docs]</a>    <span class="k">def</span> <span class="nf">get_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hz&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Region</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get selected spectral region for filtration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit</span>
<span class="sd">            Unit specifier. Should be one of ``&#39;hz&#39;``, ``&#39;ppm&#39;``, ``&#39;idx&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sanity_check</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_one_of</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;idx&quot;</span><span class="p">,</span> <span class="s2">&quot;hz&quot;</span><span class="p">,</span> <span class="s2">&quot;ppm&quot;</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_region</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;idx-&gt;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Filter.get_noise_region"><a class="viewcode-back" href="../../content/references/freqfilter.html#nmrespy.freqfilter.Filter.get_noise_region">[docs]</a>    <span class="k">def</span> <span class="nf">get_noise_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hz&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Region</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get selected spectral noise region for filtration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit</span>
<span class="sd">            Unit specifier. Should be one of ``&#39;hz&#39;``, ``&#39;ppm&#39;``, ``&#39;idx&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sanity_check</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">sfuncs</span><span class="o">.</span><span class="n">check_one_of</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;idx&quot;</span><span class="p">,</span> <span class="s2">&quot;hz&quot;</span><span class="p">,</span> <span class="s2">&quot;ppm&quot;</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_noise_region</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;idx-&gt;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_ift_and_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filtered_spectrum</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Inverse Fourier Transform and slice a filtered spectrum.</span>

<span class="sd">        Any dimension that has been filtered and IFTed is sliced in half to remove the</span>
<span class="sd">        second half of the virtual echo obtained from the IFT of a real spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fid_slice</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fid_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">filtered_spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
             <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">filtered_spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">sig</span><span class="o">.</span><span class="n">ift</span><span class="p">(</span><span class="n">filtered_spectrum</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)[</span><span class="n">fid_slice</span><span class="p">]</span></div>

    <span class="c1"># ================</span>
    <span class="c1"># Commented stuff below is related to baseline fixing.</span>
    <span class="c1"># May bring back to life at some point if I find it is actually useful.</span>

    <span class="c1"># def _get_cf_boundaries(self) -&gt; Iterable[Tuple[slice]]:</span>
    <span class="c1">#     def is_small(x):</span>
    <span class="c1">#         return x &lt; 1e-6</span>

    <span class="c1">#     def is_large(x):</span>
    <span class="c1">#         return x &gt; 1 - 1e-3</span>

    <span class="c1">#     ndim = len(self.shape)</span>
    <span class="c1">#     region = self.get_region(unit=&quot;idx&quot;)</span>
    <span class="c1">#     sg = np.real(self.sg)</span>
    <span class="c1">#     boundaries = []</span>
    <span class="c1">#     for dim, bounds in enumerate(region):</span>
    <span class="c1">#         for i, bound in enumerate(bounds):</span>
    <span class="c1">#             rcutoff = None</span>
    <span class="c1">#             lcutoff = None</span>
    <span class="c1">#             shift = 0</span>
    <span class="c1">#             while any([x is None for x in (lcutoff, rcutoff)]):</span>
    <span class="c1">#                 if i == 0:</span>
    <span class="c1">#                     if lcutoff is None and is_small(sg[bound - shift]):</span>
    <span class="c1">#                         lcutoff = bound - shift</span>
    <span class="c1">#                     if rcutoff is None and is_large(sg[bound + shift]):</span>
    <span class="c1">#                         rcutoff = bound + shift</span>
    <span class="c1">#                 if i == 1:</span>
    <span class="c1">#                     if lcutoff is None and is_large(sg[bound - shift]):</span>
    <span class="c1">#                         lcutoff = bound - shift</span>
    <span class="c1">#                     if rcutoff is None and is_small(sg[bound + shift]):</span>
    <span class="c1">#                         rcutoff = bound + shift</span>
    <span class="c1">#                 shift += 1</span>
    <span class="c1">#             boundaries.append(</span>
    <span class="c1">#                 tuple(</span>
    <span class="c1">#                     dim * [slice(None, None, None)] +</span>
    <span class="c1">#                     [slice(lcutoff, rcutoff)] +</span>
    <span class="c1">#                     (ndim - dim - 1) * [slice(None, None, None)]</span>
    <span class="c1">#                 )</span>
    <span class="c1">#             )</span>

    <span class="c1">#     return tuple(boundaries)</span>

    <span class="c1"># def _fit_sg(</span>
    <span class="c1">#     self, filtered_spectrum: np.ndarray, boundaries: Iterable[Tuple[slice]]</span>
    <span class="c1"># ) -&gt; np.ndarray:</span>
    <span class="c1">#     amp = 0.0</span>
    <span class="c1">#     slices = len(boundaries)</span>
    <span class="c1">#     for i, bounds in enumerate(boundaries):</span>
    <span class="c1">#         if i % 2 == 0:</span>
    <span class="c1">#             amp -= filtered_spectrum[bounds[0].stop] / slices</span>
    <span class="c1">#         elif i % 2 == 1:</span>
    <span class="c1">#             amp -= filtered_spectrum[bounds[0].start] / slices</span>
    <span class="c1">#     sg = self.sg</span>
    <span class="c1">#     args = (filtered_spectrum, sg, boundaries)</span>
    <span class="c1">#     amp = minimize(self._sg_cost, amp, args=args, method=&quot;BFGS&quot;)[&quot;x&quot;]</span>
    <span class="c1">#     return amp * sg</span>

    <span class="c1"># def _fit_line(</span>
    <span class="c1">#     self, filtered_spectrum: np.ndarray, boundaries: Iterable[Tuple[slice]]</span>
    <span class="c1"># ):</span>
    <span class="c1">#     x1 = boundaries[0][0].stop</span>
    <span class="c1">#     x2 = boundaries[1][0].start</span>
    <span class="c1">#     y1 = filtered_spectrum[x1]</span>
    <span class="c1">#     y2 = filtered_spectrum[x2]</span>
    <span class="c1">#     m = (y2 - y1) / (x2 - x1)</span>
    <span class="c1">#     c = (y2 + y1) - m * (x2 + x1) / 2</span>
    <span class="c1">#     x0 = (m, c)</span>
    <span class="c1">#     sg = self.sg</span>
    <span class="c1">#     args = (filtered_spectrum, sg, boundaries)</span>
    <span class="c1">#     m, c = minimize(self._linear_cost, x0, args=args, method=&quot;BFGS&quot;)[&quot;x&quot;]</span>
    <span class="c1">#     line = -(m * np.arange(filtered_spectrum.size) + c)</span>
    <span class="c1">#     return line * sg</span>

    <span class="c1"># def _fit_quadratic(</span>
    <span class="c1">#     self, filtered_spectrum: np.ndarray, boundaries: Iterable[Tuple[slice]]</span>
    <span class="c1"># ):</span>
    <span class="c1">#     x1 = boundaries[0][0].stop</span>
    <span class="c1">#     x2 = boundaries[1][0].start</span>
    <span class="c1">#     y1 = filtered_spectrum[x1]</span>
    <span class="c1">#     y2 = filtered_spectrum[x2]</span>
    <span class="c1">#     a = 0.0</span>
    <span class="c1">#     b = (y2 - y1) / (x2 - x1)</span>
    <span class="c1">#     c = (y2 + y1) - b * (x2 + x1) / 2</span>
    <span class="c1">#     x0 = (a, b, c)</span>
    <span class="c1">#     sg = self.sg</span>
    <span class="c1">#     args = (filtered_spectrum, sg, boundaries)</span>
    <span class="c1">#     a, b, c = minimize(self._quadratic_cost, x0, args=args, method=&quot;BFGS&quot;)[&quot;x&quot;]</span>
    <span class="c1">#     points = np.arange(sg.size)</span>
    <span class="c1">#     quadratic = -(a * (points ** 2) + b * points + c)</span>
    <span class="c1">#     return quadratic * sg</span>

    <span class="c1"># def _baseline_fix(self, filtered_spectrum: np.ndarray) -&gt; np.ndarray:</span>
    <span class="c1">#     boundaries = self._get_cf_boundaries()</span>
    <span class="c1">#     fix = self._fit_sg(filtered_spectrum, boundaries)</span>
    <span class="c1">#     fix += self._fit_quadratic(filtered_spectrum + fix, boundaries)</span>
    <span class="c1">#     return fix</span>

    <span class="c1"># @staticmethod</span>
    <span class="c1"># def _sg_cost(amp, *args):</span>
    <span class="c1">#     spectrum, sg, boundaries = args</span>
    <span class="c1">#     cf = 0.0</span>
    <span class="c1">#     for i, bounds in enumerate(boundaries):</span>
    <span class="c1">#         spectrum_slice = spectrum[bounds]</span>
    <span class="c1">#         sg_slice = sg[bounds]</span>
    <span class="c1">#         cf += np.sum((spectrum_slice + (amp * sg_slice)) ** 2)</span>
    <span class="c1">#     return cf</span>

    <span class="c1"># @staticmethod</span>
    <span class="c1"># def _linear_cost(coeffs, *args):</span>
    <span class="c1">#     m, c = coeffs</span>
    <span class="c1">#     spectrum, sg, boundaries = args</span>
    <span class="c1">#     cf = 0.0</span>
    <span class="c1">#     for i, bounds in enumerate(boundaries):</span>
    <span class="c1">#         spectrum_slice = spectrum[bounds]</span>
    <span class="c1">#         line = (-(m * np.arange(spectrum.size) + c) * sg)[bounds]</span>
    <span class="c1">#         cf += np.sum((spectrum_slice + line) ** 2)</span>
    <span class="c1">#     return cf</span>

    <span class="c1"># @staticmethod</span>
    <span class="c1"># def _quadratic_cost(coeffs, *args):</span>
    <span class="c1">#     a, b, c = coeffs</span>
    <span class="c1">#     spectrum, sg, boundaries = args</span>
    <span class="c1">#     cf = 0.0</span>
    <span class="c1">#     for i, bounds in enumerate(boundaries):</span>
    <span class="c1">#         spectrum_slice = spectrum[bounds]</span>
    <span class="c1">#         points = np.arange(spectrum.size)</span>
    <span class="c1">#         quad = (-(a * (points ** 2) + b * points + c) * sg)[bounds]</span>
    <span class="c1">#         cf += np.sum((spectrum_slice + quad) ** 2)</span>
    <span class="c1">#     return cf</span>

    <span class="c1"># =============</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><style>
.aligncenter {
    text-align: center;
}
</style>

<a href="https://foroozandehgroup.github.io/NMR-EsPy/">
    <img style="padding: 0px 0px 12px"
         src="https://raw.githubusercontent.com/foroozandehgroup/NMR-EsPy/master/nmrespy/images/nmrespy_full.png"
         alt="NMR-EsPy logo"
         width=230px
         height=auto />
</a>

<p class="aligncenter">
    <a href="https://github.com/foroozandehgroup/NMR-EsPy">
        <img src="https://raw.githubusercontent.com/foroozandehgroup/NMR-EsPy/master/nmrespy/images/github.png"
             alt="Github"
             style="padding: 0px 30px 0px 0px"
             width=auto
             height=30px />
    </a>

    <a href="mailto:simon.hulse@chem.ox.ac.uk?subject=NMR-EsPy%20query">
        <img src="https://raw.githubusercontent.com/foroozandehgroup/NMR-EsPy/master/nmrespy/images/email_icon.png"
             alt="email"
             style="padding: 0px 30px 0px 0px"
             width=auto
             height=30px />
    </a>

    <a href="https://foroozandeh.chem.ox.ac.uk/home">
        <img src="https://raw.githubusercontent.com/foroozandehgroup/NMR-EsPy/develop/nmrespy/images/link.png"
             alt="Group website"
             width=auto
             height=30px />
    </a>
</p><h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation index</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  
  </body>
</html>